# 🔄 Sorting Visualizer

Experience the magic of sorting algorithms through interactive visualizations! This educational tool brings sorting algorithms to life, helping you understand how they work under the hood.

## ✨ What Makes This Special?

Watch in real-time as algorithms battle it out to organize data. Whether you're a computer science student, educator, or just curious about algorithms, this visualizer offers an engaging way to explore sorting techniques.

## 🧮 Available Algorithms

### Bubble Sort
Like bubbles rising to the surface, this algorithm gradually moves larger elements to their correct positions.
- **Performance**: O(n²) typical, O(n) best case
- **Memory**: O(1)
- **Best For**: Learning fundamentals and small datasets
- **Fun Fact**: Despite its inefficiency, it's often the first sorting algorithm taught in CS courses!

### Selection Sort
Methodically selects the smallest remaining element and places it in position.
- **Performance**: Consistently O(n²)
- **Memory**: O(1)
- **Best For**: Small arrays where memory is tight
- **Fun Fact**: Makes the minimum possible number of swaps (n-1 in the worst case)

### Insertion Sort
Builds the final sorted array one item at a time, like sorting a hand of playing cards.
- **Performance**: O(n²) typical, O(n) for nearly sorted data
- **Memory**: O(1)
- **Best For**: Nearly sorted data or continuous sorting of incoming data
- **Fun Fact**: Many people naturally use this algorithm when sorting cards!

### Merge Sort
Divides and conquers its way to a sorted array through recursive splitting and merging.
- **Performance**: Reliable O(n log n)
- **Memory**: O(n)
- **Best For**: Large datasets where stability matters
- **Fun Fact**: Used as the built-in sorting algorithm in many programming languages

### Quick Sort
The speed demon of sorting algorithms, using pivots to partition and conquer.
- **Performance**: O(n log n) average, O(n²) worst case
- **Memory**: O(log n)
- **Best For**: General-purpose sorting when stability isn't required
- **Fun Fact**: Most real-world implementations use a hybrid approach combining Quick Sort with Insertion Sort

## 🎮 Interactive Features

- **Array Size Control**: Test different dataset sizes to see how algorithms scale
- **Speed Adjustment**: Slow things down to see each step or speed up for efficiency
- **Theme Toggle**: Easy on the eyes with both light and dark modes
- **Random Data**: Generate new arrays instantly to test different scenarios

## 🎯 Perfect For

- 📚 Computer Science Students
- 👩‍🏫 Algorithm Instructors
- 🧪 Performance Analysis
- 🤓 Algorithm Enthusiasts

## 💡 Learning Outcomes

- Understand sorting algorithm behaviors visually
- Compare algorithm efficiencies in real-time
- Grasp core computer science concepts
- Explore time and space complexity practically

## 🚀 Getting Started

1. Select your preferred sorting algorithm
2. Adjust the array size and sorting speed
3. Hit start and watch the magic happen!
4. Try different algorithms on the same data to compare performance

Remember: The best way to learn is by experimenting. Generate different arrays, try various sizes, and watch how each algorithm handles different scenarios!
